var x=Object.defineProperty;var J=(f,t,e)=>t in f?x(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e;var u=(f,t,e)=>J(f,typeof t!="symbol"?t+"":t,e);import{m,p as L,a as w,b as p,c as E,d as O,s as C,e as N,w as b,x as P,y as T,z as I,f as W,g as H,h as j,i as q,r as $,j as Q,k as U,l as G,n as M,o as R,q as A}from"./common-CHMphJEB.js";import{Q as D,M as F,W as V,N as z,A as K}from"./Network-256T47_T.js";class X{constructor(t){u(this,"graph");this.graph=t}markEdgeAsSelected(t,e){const a=JSON.parse(JSON.stringify(t));return a.edges[e]&&(a.edges[e].state="selectedEdge"),a}markEdgeAsPartOfPath(t,e){const a=JSON.parse(JSON.stringify(t));return a.edges[e]&&(a.edges[e].state="partOfPath"),a}markNodeAsPartOfPath(t,e){const a=JSON.parse(JSON.stringify(t));return a.nodes[e]&&(a.nodes[e].state="partOfPath"),a}markEdgeAsDeselected(t,e){const a=JSON.parse(JSON.stringify(t));return a.edges[e]&&(a.edges[e].state="deselectedEdge"),a}updateNodeLabel(t,e,a){const r=JSON.parse(JSON.stringify(t));return r.nodes[e]&&(r.nodes[e].label=a),r}markEdgeAsNormal(t,e){const a=JSON.parse(JSON.stringify(t));return a.edges[e]&&(a.edges[e].state="normal"),a}createInitialState(t){const e=this.graph.getNodeList(),a=this.graph.getEdgeList(),r=Array(e.length).fill(null),h=Array(a.length).fill(null);return e.forEach((o,i)=>{o&&(r[i]={id:i,state:"normal",label:i===t?`${o.label}(0)`:`${o.label}(∞)`})}),a.forEach((o,i)=>{o&&(h[i]={id:i,state:"normal",label:`${o.getWeight()}`})}),{nodes:r,edges:h}}fillQueue(t){const e=this.graph.getNodeList(),a=new D(e.length),r=new F(e.length),h=new Array(e.length).fill(!1);for(h[t]=!0,a.enqueue(t);!a.isEmpty();){const o=a.dequeue();o===t?r.insert({id:o,value:0}):r.insert({id:o,value:1/0});const i=this.graph.getNode(o).getAdjacencyList();for(let l=0;l<i.length;l++)i[l]!==-1&&!h[l]&&(a.enqueue(l),h[l]=!0)}return r}Run(t){const e=[],a=this.fillQueue(t),r=this.graph.getNodeList(),h=this.graph.getEdgeList(),o=new Array(r.length).fill(!1),i=new Array(r.length).fill(-1),l=new Array(h.length).fill(!1),k=new Array(h.length).fill(!1);let S=0,n=this.createInitialState(t);for(n.algorithmInfobox={information:`We assign each node a value of ∞, except for the starting node which will get a value of 0. It denotes the cost of including that node in the MST.
            Inside the loop we retrieve the element with the minimum cost from the priority-queue. With the retrieval the node will be included in the MST.
            We also check if the adjacent nodes that are not yet in the MST can be assigned a smaller cost through the current node. If so we update the priority-queue. We repeat until there are no more
            nodes left in the priority queue.`},e.push(n);!a.isEmpty();){n=JSON.parse(JSON.stringify(n)),n.algorithmInfobox={information:"We call dequeue() on the priority-queue to retrieve the node with the smallest cost of including it in the MST."},e.push(n);const d=a.extractMin();if(n=this.markNodeAsPartOfPath(n,d.id),i[d.id]!==-1){const s=i[d.id];n=this.markEdgeAsPartOfPath(n,s),S+=this.graph.getEdge(s).getWeight(),l[s]=!0}n.algorithmInfobox={information:"The node with the minimum cost to include it in the MST has been retrieved from the priority-queue."},e.push(n),o[d.id]=!0;const c=this.graph.getNode(d.id).getAdjacencyList();for(let s=0;s<c.length;s++){const g=c[s];if(g!==-1){k[g]=!0;const y=this.graph.getEdge(g).getWeight();if(n=this.markEdgeAsSelected(n,g),n.algorithmInfobox={information:"Checking whether the adjacent node is already in the MST. And if so, whether the weight of the edge connecting it to the current node is smaller the one previously set."},e.push(n),o[s]){const v=this.graph.getEdge(g).getFrom(),B=this.graph.getEdge(g).getTo();i[B]===g||i[v]===g?n=this.markEdgeAsPartOfPath(n,c[s]):n=this.markEdgeAsNormal(n,c[s]),n.algorithmInfobox={information:"Adjacent node is already in the MST. We don't do anything with it."},e.push(n)}else{const v=a.get(s).value;y<v?(a.update(s,y),i[s]=g,n=this.updateNodeLabel(n,s,`${this.graph.getLabelOfNode(s)}(${y})`),n.algorithmInfobox={information:`We can improve the cost of connecting the adjacent node to the MST.<hr>
                                ${y} < ${v==1/0?"∞":v}`},e.push(n)):(n=JSON.parse(JSON.stringify(n)),n.algorithmInfobox={information:"We can't improve the cost of connecting the adjacent node to the MST."},e.push(n)),n=this.markEdgeAsNormal(n,c[s])}}}}n=JSON.parse(JSON.stringify(n));for(let d=0;d<k.length;d++)k[d]&&!l[d]&&(n=this.markEdgeAsDeselected(n,d));return n.algorithmInfobox={information:`Algorithm finished running!<hr>Minimum spanning tree of the weighted graph has been created with a total weight of: ${S}.`},e.push(n),e}}class Y{constructor(){u(this,"network");u(this,"selectedEdgeId",null);u(this,"startingNodeId",null);u(this,"canvasState","idle");u(this,"algorithm");u(this,"animation");const t=new V;this.network=new z(t,!1,!0),this.algorithm=new X(t),this.animation=new K(this.network),this.setUpNetworkEventListeners(),this.setUpUiEventListeners()}changeCanvasState(t){if((this.canvasState==="run-animation"||this.canvasState==="animation-running")&&t!=="idle"&&t!=="animation-running")return;const e=this.canvasState;switch(this.canvasState=t,t){case"add-edge-mode":N("to create an edge click and drag from one node to the other"),this.network.addEdgeModeOn();break;case"add-node-mode":N("click on the canvas to create a node"),this.network.addNodeModeOn();break;case"delete":N("select an element to delete"),this.network.deleteElementModeOn();break;case"idle":(e==="run-animation"||e==="animation-running")&&(this.animation.escapeAnimation(),p(O),p(C)),this.startingNodeId=null,N("idle mode (click on edges to modify weights)"),p(L),this.network.resetToIdle();break;case"run-animation":N("select starting node"),b(),this.selectedEdgeId=null,this.network.resetToIdle();break;case"animation-running":m(L),m(w),p(E),m(O),m(C),this.network.fitGraphIntoAnimationSpace(),this.network.disableEverything(),this.animation.start();break}b()}selectNodeHandle(t){if(this.canvasState!=="run-animation")return;this.startingNodeId=t;const e=this.algorithm.Run(this.startingNodeId);this.animation.setAnimationStates(e),this.changeCanvasState("animation-running")}selectEdgeHandle(t){this.canvasState==="animation-running"||this.canvasState==="run-animation"||this.canvasState==="idle"&&(m(P),this.selectedEdgeId=t,T.textContent="Change weight of the selected edge",I.value=`${this.network.getEdgeWeight(this.selectedEdgeId)}`)}canvasBlankClickHandle(){b()}setUpNetworkEventListeners(){this.selectNodeHandle=this.selectNodeHandle.bind(this),this.selectEdgeHandle=this.selectEdgeHandle.bind(this),this.canvasBlankClickHandle=this.canvasBlankClickHandle.bind(this),this.network.onSelectEdge(this.selectEdgeHandle),this.network.onSelectNode(this.selectNodeHandle),this.network.onCanvasBlankClick(this.canvasBlankClickHandle)}setUpUiEventListeners(){var t,e,a,r,h,o,i,l,k,S,n,d;(t=W)==null||t.addEventListener("click",()=>{this.changeCanvasState("add-edge-mode")}),(e=H)==null||e.addEventListener("click",()=>{this.changeCanvasState("add-node-mode")}),(a=j)==null||a.addEventListener("click",()=>{this.changeCanvasState("delete")}),(r=q)==null||r.addEventListener("click",()=>{this.changeCanvasState("idle")}),(h=$)==null||h.addEventListener("click",()=>{this.changeCanvasState("run-animation")}),I.addEventListener("input",()=>{const c=Number.parseInt(I.value),s=this.selectedEdgeId;this.network.updateEdge({id:s,weight:c})}),(o=Q)==null||o.addEventListener("click",()=>{this.animation.resetAnimation(),p(w),m(E)}),(i=w)==null||i.addEventListener("click",()=>{this.animation.pause(),p(w),m(E)}),(l=U)==null||l.addEventListener("click",()=>{this.animation.setAnimationStateForward(),this.animation.animateCurrentState()}),(k=G)==null||k.addEventListener("click",()=>{this.animation.setAnimationStateBackward(),this.animation.animateCurrentState()}),(S=E)==null||S.addEventListener("click",()=>{this.animation.continueAnimation(),p(E),m(w)}),(n=M)==null||n.addEventListener("input",()=>{let c=Number.parseInt(M.value);R.textContent=`speed: ${c}x`,this.animation.setAnimationSpeedChange(1e3/c)}),(d=A)==null||d.addEventListener("input",()=>{A.value!=="load a graph"&&this.canvasState!=="run-animation"&&this.canvasState!=="animation-running"&&this.network.loadPreset("prim",A.value)})}}new Y;
