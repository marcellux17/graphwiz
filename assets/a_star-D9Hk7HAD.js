var P=Object.defineProperty;var $=(f,t,n)=>t in f?P(f,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):f[t]=n;var u=(f,t,n)=>$(f,typeof t!="symbol"?t+"":t,n);import{m as g,p as x,a as b,s as E,d as O,b as m,c as k,e as p,t as C,u as J,v as q,f as F,g as D,h as M,i as R,r as Q,j as W,k as H,l as j,n as B,o as U,q as I}from"./common-CHMphJEB.js";import{M as V,W as G,N as z,A as _}from"./Network-256T47_T.js";class K{constructor(t){u(this,"graph");u(this,"distanceTable");this.graph=t,this.distanceTable=Array(this.graph.getNodeList().length).fill(null)}createPathHighLightState(t,n,e,o){let a=t,s=this.graph.getNode(e),d={information:`Algorithm finished running!<hr>Shortest path found between ${this.graph.getLabelOfNode(n)} and ${this.graph.getLabelOfNode(e)}.`,dataStructure:{type:"priority-queue",ds:[]}};for(a.algorithmInfobox=d;s!==null;){const i=s.getId(),r=o[i];if(a=this.markNodeAsPartOfPath(a,i),r!==-1){const h=s.getAdjacencyList()[r];a=this.markEdgeAsPartOfPath(a,h),s=this.graph.getNode(r)}else s=null}return a}markNodeAsVisited(t,n){const e=JSON.parse(JSON.stringify(t));return e.nodes[n]&&(e.nodes[n].state="visitedNode"),e}markEdgeAsSelected(t,n){const e=JSON.parse(JSON.stringify(t));return e.edges[n]&&(e.edges[n].state="selectedEdge"),e}markEdgeAsPartOfPath(t,n){const e=JSON.parse(JSON.stringify(t));return e.edges[n]&&(e.edges[n].state="partOfPath"),e}markNodeAsPartOfPath(t,n){const e=JSON.parse(JSON.stringify(t));return e.nodes[n]&&(e.nodes[n].state="partOfPath"),e}markEdgeAsNormal(t,n){const e=JSON.parse(JSON.stringify(t));return e.edges[n]&&(e.edges[n].state="normal"),e}updateNodeLabel(t,n,e){const o=JSON.parse(JSON.stringify(t));return o.nodes[n]&&(o.nodes[n].label=e),o}createInitialState(t){const n=this.graph.getNodeList(),e=this.graph.getEdgeList(),o=Array(n.length).fill(null),a=Array(e.length).fill(null);return n.forEach((s,d)=>{s&&(o[d]={id:d,state:"normal",label:d===t?s.label:`${s.label}(∞)`})}),e.forEach((s,d)=>{s&&(a[d]={id:d,state:"normal",label:`${s.getWeight()}`})}),{nodes:o,edges:a}}measureDistancesFromAllNodesToDestinationNode(t){const n=this.graph.getNodeList();for(let e=0;e<n.length;e++)n[e]!==null&&(this.distanceTable[e]=this.measureDistance(n[t],n[e]))}measureDistance(t,n){return Math.floor(Math.sqrt((t.x-n.x)**2+(t.y-n.y)**2)/10)}getLabelsForQueueRepresentation(t){return t.map(n=>this.graph.getLabelOfNode(n))}Run(t,n){const e=[],o=this.graph.getNodeList(),a=new V(o.length),s=Array(o.length).fill(!1),d=Array(o.length).fill(-1);this.measureDistancesFromAllNodesToDestinationNode(n),this.graph.getNodeList().forEach(h=>{h&&h.getId()!==t?a.insert({id:h.getId(),value:1/0}):h&&a.insert({id:h.getId(),value:this.distanceTable[h.getId()]})});let i=this.createInitialState(t);i.algorithmInfobox={information:`We assign each node a value of ∞, except for the starting node which will get a value of 0. It denotes the shortest distance known from the source node.
            Inside the loop we retrieve the element that has the smallest possible value of g(x) + h(x). With the retrieval the the shortest distance to the node is finalized.
            We also check if a shorter distance is possible through the current node to the adjacent node. If so we update the priority-queue. We repeat this until the destination node is retrieved.
            <hr>
            h(x): heuristic, in our case its euclidean distance<br>
            g(x): shortest distance known from source node`},e.push(i),i=JSON.parse(JSON.stringify(i)),i.algorithmInfobox={information:"Selecting node from priority queue with the smallest distance",dataStructure:{type:"priority-queue",ds:this.getLabelsForQueueRepresentation(a.toArray())}},e.push(i);let r=a.extractMin();for(s[r.id]=!0,i=this.markNodeAsVisited(i,r.id),i.algorithmInfobox={information:"Node with the smallest g(x) + h(x) selected from priority queue.",dataStructure:{type:"priority-queue",ds:this.getLabelsForQueueRepresentation(a.toArray())}},e.push(i);r.id!==n;){const h=this.graph.getNode(r.id);let c=null;const N=h.getAdjacencyList();for(let l=0;l<N.length;l++){c!==null&&(i=this.markEdgeAsNormal(i,c));const v=N[l];if(v!==-1&&!s[l]){const w=this.distanceTable[l],T=this.distanceTable[r.id],L=this.graph.getEdge(v).getWeight(),S=a.get(l).value-w,A=r.value-T,y=A+L;i=this.markEdgeAsSelected(i,v),i.algorithmInfobox={information:`Checking for adjacent nodes if the distance through the node currently being visited is smaller than the distance previously set:<br> 
                        <br>${A} + ${L} < ? ${S==1/0?"∞":S}`,dataStructure:{type:"priority-queue",ds:this.getLabelsForQueueRepresentation(a.toArray())}},e.push(i),y<S?(d[l]=r.id,i=this.updateNodeLabel(i,l,`${this.graph.getLabelOfNode(l)}(${y})`),i.algorithmInfobox={information:`distance through current node < current smallest distance to neighbour<br> (${y} < ${S==1/0?"∞":S})`,dataStructure:{type:"priority-queue",ds:this.getLabelsForQueueRepresentation(a.toArray())}},e.push(i),a.update(l,y+w)):(i=JSON.parse(JSON.stringify(i)),i.algorithmInfobox={information:"distance through current node > current smallest distance to neighbour<hr> no updates",dataStructure:{type:"priority-queue",ds:this.getLabelsForQueueRepresentation(a.toArray())}},e.push(i)),c=v}}c!==null&&(i=this.markEdgeAsNormal(i,c)),s[r.id]=!0,i=JSON.parse(JSON.stringify(i)),i.algorithmInfobox={information:`Selecting node from priority queue with the smallest g(x) + h(x)<br>
                h(x): heuristic, in our case its euclidean distance<br>
                g(x): shortest distance known from source node`,dataStructure:{type:"priority-queue",ds:this.getLabelsForQueueRepresentation(a.toArray())}},e.push(i),r=a.extractMin(),i=this.markNodeAsVisited(i,r.id),i.algorithmInfobox={information:"Node with the smallest g(x) + h(x) selected from priority queue.",dataStructure:{type:"priority-queue",ds:this.getLabelsForQueueRepresentation(a.toArray())}},e.push(i)}return e.push(this.createPathHighLightState(i,t,n,d)),e}}class X{constructor(){u(this,"network");u(this,"startingNodeId",null);u(this,"destinationNodeId",null);u(this,"canvasState","idle");u(this,"algorithm");u(this,"animation");const t=new G;this.network=new z(t,!0,!0),this.algorithm=new K(t),this.animation=new _(this.network),this.setUpNetworkEventListeners(),this.setUpUiEventListeners()}changeCanvasState(t){if((this.canvasState==="run-animation"||this.canvasState==="animation-running")&&t!=="idle"&&t!=="animation-running")return;const n=this.canvasState;switch(this.canvasState=t,t){case"add-edge-mode":p("to create an edge click and drag from one node to the other"),this.network.addEdgeModeOn();break;case"add-node-mode":p("click on the canvas to create a node"),this.network.addNodeModeOn();break;case"delete":p("select an element to delete"),this.network.deleteElementModeOn();break;case"idle":(n==="run-animation"||n==="animation-running")&&(this.animation.escapeAnimation(),m(O),m(E)),this.startingNodeId=null,this.destinationNodeId=null,J.textContent="start: ",q.textContent="dest: ",p("idle mode"),m(C),m(x),this.network.resetToIdle();break;case"run-animation":p("select starting node"),g(C),this.network.resetToIdle();break;case"animation-running":g(x),g(b),g(E),g(O),m(k),this.network.fitGraphIntoAnimationSpace(),this.network.disableEverything(),this.animation.start();break}}selectNodeHandle(t){if(this.canvasState!=="run-animation")return;if(this.startingNodeId===null){this.startingNodeId=t,p("choose destination node"),J.textContent=`start: ${this.network.getLabelOfNode(this.startingNodeId)}`;return}if(this.destinationNodeId=t,this.destinationNodeId===this.startingNodeId){p("choose destination node");return}if(!this.network.areConnected(this.startingNodeId,this.destinationNodeId)){p("no path from starting node to destination node, choose another destination node");return}q.textContent=`dest: ${this.network.getLabelOfNode(this.destinationNodeId)}`;const e=this.algorithm.Run(this.startingNodeId,this.destinationNodeId);this.animation.setAnimationStates(e),this.changeCanvasState("animation-running")}setUpNetworkEventListeners(){this.selectNodeHandle=this.selectNodeHandle.bind(this),this.network.onSelectNode(this.selectNodeHandle)}setUpUiEventListeners(){var t,n,e,o,a,s,d,i,r,h,c,N;(t=F)==null||t.addEventListener("click",()=>{this.changeCanvasState("add-edge-mode")}),(n=D)==null||n.addEventListener("click",()=>{this.changeCanvasState("add-node-mode")}),(e=M)==null||e.addEventListener("click",()=>{this.changeCanvasState("delete")}),(o=R)==null||o.addEventListener("click",()=>{this.changeCanvasState("idle")}),(a=Q)==null||a.addEventListener("click",()=>{this.changeCanvasState("run-animation")}),(s=W)==null||s.addEventListener("click",()=>{this.animation.resetAnimation(),m(b),g(k)}),(d=b)==null||d.addEventListener("click",()=>{this.animation.pause(),m(b),g(k)}),(i=H)==null||i.addEventListener("click",()=>{this.animation.setAnimationStateForward(),this.animation.animateCurrentState()}),(r=j)==null||r.addEventListener("click",()=>{this.animation.setAnimationStateBackward(),this.animation.animateCurrentState()}),(h=k)==null||h.addEventListener("click",()=>{this.animation.continueAnimation(),m(k),g(b)}),(c=B)==null||c.addEventListener("input",()=>{let l=Number.parseInt(B.value);U.textContent=`speed: ${l}x`,this.animation.setAnimationSpeedChange(1e3/l)}),(N=I)==null||N.addEventListener("input",()=>{I.value!=="load a graph"&&this.canvasState!=="run-animation"&&this.canvasState!=="animation-running"&&this.network.loadPreset("a_star",I.value)})}}new X;
